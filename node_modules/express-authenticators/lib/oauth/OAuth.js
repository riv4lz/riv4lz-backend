"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _OAuth_instances, _OAuth_authorizationHeader;
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const oauthUtils_1 = require("./oauthUtils");
const OAuthError_1 = __importDefault(require("./OAuthError"));
const r3986_1 = __importDefault(require("r3986"));
const lib_1 = require("../lib");
const url_1 = require("url");
const version = '1.0';
class OAuth {
    // eslint-disable-next-line no-useless-constructor
    constructor(config) {
        this.config = config;
        _OAuth_instances.add(this);
    }
    authenticate({ store }) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.signAndFetch(this.config.requestTokenUrl, {
                method: 'POST',
                oauthHeaders: {
                    oauth_callback: this.config.callbackUrl,
                }
            });
            if (!response.ok)
                throw new OAuthError_1.default(yield response.text());
            const { oauth_token, oauth_token_secret, oauth_callback_confirmed } = Object.fromEntries(new url_1.URLSearchParams(yield response.text()));
            if (oauth_callback_confirmed !== 'true')
                throw new Error('Failed to request access token');
            yield store((0, lib_1.encodeSessionData)({ secret: oauth_token_secret }));
            return `${this.config.authorizeUrl}?${new url_1.URLSearchParams({ oauth_token }).toString()}`;
        });
    }
    signAndFetch(url, options, tokenPayload) {
        return (0, node_fetch_1.default)(`${url}${options.qs ? `?${new url_1.URLSearchParams(options.qs).toString()}` : ''}`, {
            headers: Object.assign(Object.assign({}, options.headers), { Authorization: __classPrivateFieldGet(this, _OAuth_instances, "m", _OAuth_authorizationHeader).call(this, url, options, tokenPayload) }),
            method: options.method,
            body: options.body && new url_1.URLSearchParams(options.body).toString(),
        });
    }
    callback({ pop }, rawQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const searchParams = new url_1.URLSearchParams(rawQuery);
            const oauth_token = searchParams.get('oauth_token');
            const oauth_verifier = searchParams.get('oauth_verifier');
            const sessionSecret = (0, lib_1.decodeSessionData)(pop()).secret;
            if (!sessionSecret)
                throw new OAuthError_1.default('Last token secret lost');
            const response = yield this.signAndFetch(this.config.accessTokenUrl, {
                oauthHeaders: {
                    oauth_verifier: oauth_verifier,
                },
                method: 'POST'
            }, {
                token: oauth_token,
                secret: sessionSecret
            });
            if (!response.ok)
                throw new OAuthError_1.default(yield response.text());
            const { oauth_token: token, oauth_token_secret: secret, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            user_id, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            screen_name } = Object.fromEntries(new url_1.URLSearchParams(yield response.text()));
            return {
                token: token,
                secret: secret
            };
        });
    }
}
exports.default = OAuth;
_OAuth_instances = new WeakSet(), _OAuth_authorizationHeader = function _OAuth_authorizationHeader(url, { method = 'GET', body = {}, qs, oauthHeaders }, tokenSet) {
    const authHeaders = Object.assign(Object.assign({ oauth_consumer_key: this.config.consumerKey, oauth_signature_method: this.config.signingMethod, oauth_timestamp: (0, oauthUtils_1.getTimestamp)(), oauth_nonce: (0, oauthUtils_1.getNonce)(), oauth_version: version }, tokenSet && { oauth_token: tokenSet.token }), oauthHeaders);
    const allParams = Object.assign(Object.assign(Object.assign({}, body), qs), authHeaders);
    const allPairs = Object.keys(allParams)
        .map(k => [k, allParams[k]])
        .map(arr => arr.map(r3986_1.default))
        .sort(([a1, b1], [a2, b2]) => a1 < a2
        ? -1
        : a1 > a2
            ? 1
            : b1 < b2
                ? -1
                : b1 > b2
                    ? 1
                    : 0)
        .map(([k, v]) => `${k}=${v}`)
        .join('&');
    const baseString = `${method}&${(0, r3986_1.default)(url)}&${(0, r3986_1.default)(allPairs)}`;
    const signature = (0, oauthUtils_1.oauthSign)(this.config.signingMethod, baseString, this.config.consumerSecret, tokenSet === null || tokenSet === void 0 ? void 0 : tokenSet.secret);
    const signedAuthHeaders = Object.assign(Object.assign({}, authHeaders), { oauth_signature: signature });
    const signedAuthHeadersRaw = Object
        .keys(signedAuthHeaders)
        .map(k => `${(0, r3986_1.default)(k)}="${(0, r3986_1.default)(signedAuthHeaders[k])}"`)
        .join(', ');
    return `OAuth ${signedAuthHeadersRaw}`;
};
